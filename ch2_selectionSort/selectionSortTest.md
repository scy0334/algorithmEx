2-1 가계부 앱을 개발하고 있다고 생각해보세요. 여러분은 돈을 어디에 썼는지 매일 앱에 기록합니다. 월말이 되면 지출을 되돌아보고 소비 금액의 합계를 계산합니다. 그러니까 자료를 읽는 것보다 삽입하는 일이 훨씬 많습니다. 그럼 배열을 사용해야 할까요? 아니면 리스트를 사용해야 할까요?
- 답 : List
- 해석 : Array의 경우 각 메모리 주소별로 정렬이 되어 있기 때문에 새로운 Element를 삽입하려면 모든 원소의 위치를 바꿔야 하기 때문에 O(n)만큼의 작업이 필요하지만, List의 경우에는 이전 Element가 무엇을 가리키는지 바꾸기만 하면 되므로 그 작업이 O(1)만큼이기 때문에, 이 경우에는 List로 관리하는 게 훨씬 더 효율적임.

2-2 레스토랑에서 고객의 주문을 받아서 처리하는 앱을 만들고 있다고 가정하죠. 그 앱은 우선 주문 목록을 저장해야 합니다. 서비스 담당 직원은 이 리스트에 계속 주문을 추가하고, 요리사는 리스트에서 주문을 꺼내어 조리를 합니다. 이런 것을 주문 Queue라고 합니다. 서비스 담당 직원은 큐의 뒤에 주문을 추가하고 요리사는 큐의 앞에서 첫 번째 주문을 꺼내어 요리합니다. 

여러분은 이러한 큐를 구현하는데 배열을 사용하겠습니까? 아니면 연결 리스트를 사용하겠습니까?
- 오답 : Array
- 내 생각 : 이 경우에는 요리의 주문을 조회만 하지 중간에 삽입하거나 삭제하는 과정이 없기 때문에 array가 훨씬 용이하다. Array의 경우에는 바로 몇 번째 주문인지 확인이 가능하기 때문에 O(1)만큼이 걸리지만, List의 경우에는 각 장소별로 따라가면서 order를 조회해야 하기 때문에 O(n)만큼이 소요된다. 
  
- 정답 : 삽입이 많이 발생하는 경우에는 연결 리스트가 훨씬 좋음. 요리사가 큐의 가장 첫 번째 주문만 처리하므로 임의의 위치를 읽거나 검색할 필요가 없으므로 연결 리스트가 좋음(ㅠㅠ 문제는 잘못 이해했군요)

2-3 사고 실험을 해보죠. 페이스북이 사용자 이름 목록을 가지고 있다고 합시다. 누군가가 페이스북에 로그인하려고 하면 사용자 이름 목록에서 이름을 검색해야 합니다. 만약 사용자 이름 목록에 아이디가 없다면 로그인 할 수 없겠죠. 사람들은 페이스북에 빈번하게 로그인합니다. 그럼 이름 목록 검색도 자주 이루어진다는 겁니다. 페이스북이 이 목록을 검색하기 위해 이진 탐색을 사용한다고 가정한다면, 이진 탐색을 하기 위해 임의 접근이 가능해야 합니다. 즉, 이름 목록 중간에 있는 값도 즉시 읽을 수 있어야 합니다. 이 경우에는 목록을 구현하는데 배열을 쓸까요? 아니면 연결 리스트를 쓸까요?
- 답 : Array
- 해석 : 이진 탐색을 사용하려면 정보가 정렬이 되있다는 가정인데, list의 경우에는 각 요소에 대한 임의 접근이 안 되는 방면에, array는 임의 접근이 가능하여 array로 목록을 구현하는 게 바람직함.

2-4 페이스북에는 새로운 사용자 등록도 자주 발생합니다. 만약 사용자 이름 목록을 저장하기 위해 배열을 쓰리고 했다면 삽입을 위한 배열에서 발생하는 단점은 무엇일까요? 현재는 로그인 할 때 이름을 찾기 위해 이진 탐색을 사용하고 있다고 가정했을 때 이 배열에 새로운 사용자를 추가하면 어떻게 될까요?
- 답 : 배열의 경우 새로운 값을 추가하거나 수정/삭제 할 때는 O(n)만큼의 작업이 소요되기 때문에 엄청난 메모리의 용량이 소요될 수 있기 때문에 전체적인 효율성에 있어서 큰 문제가 발생할 수 있다. 새로운 사용자가 추가될 경우, 이진 탐색을 이용하여 각각의 이름의 아스키코드를 통해 new user의 이름 전의 사용자의 이름을 찾아내야 하고, 해당 current user 뒤에 있는 메모리들을 한 칸씩 이동시킨 후 new user의 정보를 current user 메모리 뒤에 추가해야 함.

2-5 페이스북은 실제로 사용자 정보를 저장하기 위해 배열이나 연결 리스트를 사용하지 않습니다. 다음과 같은 복합 자료구조를 생각해 봅시다. 26개의 칸이 있는 배열이 있습니다. 각각의 칸은 각자 다른 연결 리스트를 가리키고 있습니다. 예를 들어, 배열의 첫 번째 칸은 A로 시작하는 모든 사용자 이름을 담은 연결 리스트를 가리키죠. 마찬가지로 두 번째 칸은 B로 시작하는 모든 사용자 이름을 담은 연결 리스트를 가리킵니다. 

예를 들어, 'Adit B'라는 사용자가 페이스북에 새로 등록하면 여러분은 이름을 리스트에 저장하기를 원하겠죠. 그러면 배열의 첫 번재 칸으로 가서 연결 리스트를 찾아 'Adit B'라는 이름을 마지막에 추가합니다. 만약 'Zakhir H'라는 이름을 검색하고 싶다면 26번째 칸으로 가서 Z로 시작되는 모든 이름을 가진 연결 리스트로 갑니다. 이 리스트를 검색하여 'Zakhir H'라는 이름을 찾습니다. 

이런 복합 자료구조를 배열이나 연결 리스트와 비교해 봅시다. 검색이나 삽입을 할 때 어떤 방법이 빠를까요? 빅오 표기법까지 대답할 필요는 없고 그냥 어떤 자료구조가 빠른지, 느린지만 대답하면 됩니다. 
- 내 생각 : 위와 같이 복합 자료구조를 진행하게 되면, 이름을 검색하는 과정에서 첫 알파벳을 찾는 것은 O(1)이지만, 그 이후 리스트에서 이름을 찾는 과정에서 O(n)만큼이 소요되지만, 검색 분량이 짧기 때문에 List보다는 검색이 빠르겠지만, 바로 O(1)로 검색이 가능한 Array보다는 검색 속도가 느릴 것으로 보임. 대신에 사용자 정보를 추가하고 수정하는 과정에 있어서는 바로 O(1)로 알파벳을 검색하여 바로 O(1)의 속도로 삽입/수정/삭제 등이 가능하기 때문에 List의 정보 처리 속도와는 큰 차이가 없는 반면에, O(n) 수준으로 검색을 해야 하는 Array보다는 빠를 것으로 보임. 즉, 검색할 때는 List보다 빠르고 Array보다는 느릴 수 있는 반면에, Modification이 필요한 경우에는 List와 속도가 같고 Array 보다는 훨씬 빠를 가능성이 높음. 
  
- 정답 : 복합 자료구조는 검색의 경우에는 배열보다 느리고 연결 리스트보다는 빠름. 삽입의 경우에는 배열보다는 빠르고 연결 리스트와는 같은 시간이 소요 됨. 즉, 배열보다는 검색 시간 측면에서만 느리고 연결 리스트보다는 모든 면에서 좋거나 최소한 같음. 이 책의 뒷 부분에서는 해시 테이블이라고 하는 또 다른 복합 자료구조 이야기를 할 건데, 이 자료 구조는 간단한 자료 구조로부터 어떻게 복잡한 형태의 자료구조를 만들어 나가는지에 대한 아이디어를 줄 수 있음. 페이스북은 아마도 여러 가지 다른 데이터베이스를 사용하고, 각각의 데이터베이스 내부에서는 해시 테이블이나 B-트리와 같은 다양한 자료구조를 쓸 것임.. 배열과 연결 리스트는 이러한 복잡한 자료구조를 만드는 기초가 됨. 